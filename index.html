<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplex Noise Fire Shader</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }

        #cardOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: calc(min(100vw, 100vh) * 0.56);
            height: calc(min(100vw, 100vh) * 0.76);
            border-radius: 12px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 8%;
            overflow: hidden;
        }

        #cardOverlay h1 {
            font-family: 'Playfair Display', Georgia, serif;
            font-weight: 700;
            font-size: clamp(20px, 4.2vmin, 40px);
            line-height: 1.25;
            color: #E8DCD5;
            margin-bottom: 0.8em;
        }

        #cardOverlay .body-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, sans-serif;
            font-size: clamp(12px, 2vmin, 18px);
            line-height: 1.65;
            color: #B8AFA8;
            margin-bottom: 2em;
        }

        .columns {
            display: flex;
            gap: 2em;
        }

        .column {
            flex: 1;
        }

        .column h3 {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, sans-serif;
            font-size: clamp(10px, 1.5vmin, 14px);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #A66C94;
            margin-bottom: 0.8em;
        }

        .column p {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, sans-serif;
            font-size: clamp(12px, 1.8vmin, 16px);
            line-height: 1.55;
            color: #D5CCC5;
            margin-bottom: 0.5em;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <div id="cardOverlay">
        <h1>Downplaying what you&#x2019;ve done doesn&#x2019;t make you humble.</h1>
        <p class="body-text">You called your promotion &#x201C;lucky.&#x201D; Before that it was &#x201C;right place right time.&#x201D; The person who narrates themselves out of their own story doesn&#x2019;t get seen &mdash; they get overlooked.</p>
        <div class="columns">
            <div class="column">
                <h3>Embrace</h3>
                <p>Saying &#x201C;I earned that&#x201D;</p>
                <p>Receive, don&#x2019;t deflect</p>
            </div>
            <div class="column">
                <h3>Release</h3>
                <p>Crediting luck</p>
                <p>Dismissing praise</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            document.body.innerHTML = '<p style="color:white;padding:2em;">WebGL is not supported in this browser.</p>';
            throw new Error('WebGL not supported');
        }

        // --- Shader sources loaded inline ---
        const vertexShaderSource = `
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

        let fragmentShaderSource = null;

        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertSrc, fragSrc) {
            const vertShader = compileShader(gl, gl.VERTEX_SHADER, vertSrc);
            const fragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragSrc);
            if (!vertShader || !fragShader) return null;

            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        async function init() {
            // Fetch fragment shader from file
            const response = await fetch('shader.frag');
            fragmentShaderSource = await response.text();

            const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
            if (!program) {
                document.body.innerHTML = '<p style="color:white;padding:2em;">Shader compilation failed. Check the console for details.</p>';
                return;
            }

            gl.useProgram(program);

            // Full-screen quad (two triangles)
            const vertices = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                -1,  1,
                 1, -1,
                 1,  1,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

            // Uniforms
            const uTime = gl.getUniformLocation(program, 'iTime');
            const uResolution = gl.getUniformLocation(program, 'iResolution');
            const uMouse = gl.getUniformLocation(program, 'iMouse');

            // Mouse tracking
            let mouseX = 0, mouseY = 0;
            let mouseDown = false;

            canvas.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const rect = canvas.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    mouseX = (e.clientX - rect.left) * dpr;
                    mouseY = (rect.height - (e.clientY - rect.top)) * dpr; // flip Y
                }
            });
            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                mouseX = (e.clientX - rect.left) * dpr;
                mouseY = (rect.height - (e.clientY - rect.top)) * dpr;
            });
            canvas.addEventListener('mouseup', () => { mouseDown = false; });

            // Resize handling
            window.addEventListener('resize', resize);
            resize();

            // Render loop
            const startTime = performance.now();

            function render() {
                const elapsed = (performance.now() - startTime) / 1000.0;

                gl.uniform1f(uTime, elapsed);
                gl.uniform2f(uResolution, canvas.width, canvas.height);
                gl.uniform4f(uMouse, mouseX, mouseY, mouseDown ? 1.0 : 0.0, 0.0);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }

            render();
        }

        init();
    </script>
</body>
</html>
